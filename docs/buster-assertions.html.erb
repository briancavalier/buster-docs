        <h1><code>buster.assertions</code></h1>
        <dl>
          <dt>Version</dt>
          <dd>0.8.0 <span class="date">(2011-11-28)</span></dd>
          <dt>Module</dt>
          <dd><code>require("buster-assertions");</code></dd>
          <dt>In browsers</dt>
          <dd><code>buster.assertions;</code></dd>
        </dl>
        <p>
          A collection of assertions to be used with a unit testing framework.
          <strong>buster-assertions</strong> works well with any CommonJS
          compliant testing framework out of the box, and can easily be
          configured to work with most any testing framework.
        </p>
        <p>
          <strong>buster-assertions</strong> contains lots of assertions. We
          strongly believe that high-level assertions are essential in the
          interest of producing clear and intent-revealing tests, and they also
          give you to-the-point failure messages even if you don't specify
          custom messages.
        </p>
        <h3>Overriding assertion messages</h3>
        <p>
          The default assertion messages can be overridden per assertion. The
          properties to overwrite are listed with each assertion along with the
          arguments the string is fed. Here's an example of providing a new
          assertion failure message for
          <%= anchor("<code>buster.assertions.assert.equals</code>", "assert-equals") %>:
        </p>
        <pre><code>var assert = buster.assertions.assert;
assert.equals.msgFail = "${0}I wanted ${1} == ${2}!"

try {
    assert.equals(3, 4, "Crap.");
} catch (e) {
    console.log(e.message);
}

// Prints:
// "Crap. I wanted 3 == 4!"</code></pre>
        <h3>Assertions and refutations</h3>
        <p>
          Unlike most assertion libraries, <strong>buster-assertion</strong>
          does not have <code>assert.notXyz</code> assertions to refute some
          fact. Instead, it has <em>refutations</em>, heavily inspired by Ruby's
          <a href="http://bfts.rubyforge.org/minitest/">minitest</a>:
        </p>
        <pre><code>var assert = buster.assertions.assert;
var refute = buster.assertions.refute;

assert.equals(42, 42);
refute.equals(42, 43);</code></pre>
        <p>
          Refutations help express "assert not ..." style verification in a much
          clearer way. It also brings with it a nice consistency in that
          any <code>assert.xyz</code> always has a corresponding
          <code>refute.xyz</code> that does the opposite check.
        </p>
        <h3>Adding custom assertions</h3>
        <p>
          Custom, project specific assertions can help the readability of your
          tests, and improve your test feedback. You can add assertions that
          behave exactly like the built-in ones (i.e. with counting, message
          formatting, expectations and more) by using the <code>add</code>
          method.
        </p>
        <div class="section">
          <h2 id="<%= id('events') %>">Events</h2>
          <div class="intro">
            <p>
              <code>buster.assertions</code> is an <%= m("eventEmitter") %>. Listen to
              events with <code>on</code>:
            </p>
            <pre><code>buster.assertions.on("failure", function (err) {
                console.log(err.message);
                });</code></pre>
          </div>
          <%= event("pass") %>
          <p>
            Assertion passed. The callback is invoked with the assertion name,
            e.g. <code>"isString"</code>, as its only argument. Note that this
            event is also emitted when refutations pass.
          </p>
          <%= event("failure", [[:error, "#AssertionError"]]) %>
          <p>
            Assertion failed. The callback is invoked with an
            <%=l "AssertionError" %> object.
          </p>
        </div>
        <div class="section">
          <h2 id="<%= id('assertions') %>">Assertions</h2>
          <p>
            Examples assume that you have
            aliased <code>buster.assertions.assert</code> as such:
          </p>
          <pre><code>var assert = buster.assertions.assert;</code></pre>
          <h3 id="<%= id('assert') %>" data-title="+assert(actual[, msg])+"><code>assert(actual[, message]);</code></h3>
          <p>
            Fails if <code>actual</code> is falsy
            (<code>0</code>, <code>""</code>, <code>null</code>, <code>undefined</code>,
            <code>NaN</code>). Fails with either the provided message or "Expected
            null to be truthy". This behavior differs from most other assertions,
            which prepend the failure message with the optional message argument.
          </p>
          <pre><code>assert({ not: "Falsy" }, "This will pass");
assert(null, "This will fail");
assert(null); // Fails
assert(34);   // Passes
</code></pre>
          <h3 id="<%= id('assert-same') %>" data-title="+same(expected, actual[, msg])+"><code>assert.same(expected, actual[, message])</code></h3>
          <p>
            Fails if <code>actual</code> <strong>is not</strong> the same object
            (<code>===</code>) as <code>expected</code>. To compare similar
            objects, such as <code>{ name: "Chris", id: 42 }</code> and <code>{
              id: 42, name: "Chris" }</code> (not the same instance), see
            <%=l "assert.equals" %>. The optional message is prepended
            to the failure message if provided.
          </p>
          <pre><code>var obj = { id: 42, name: "Chris" };

assert.same(obj, obj, "This will pass");
assert.same(obj, { id: 42, name: "Chris" }, "This will fail");
assert.same(obj, obj);                       // Passes
assert.same(obj, { id: 42, name: "Chris" }); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.same.msgFail = "${0}Expected ${1} to be the same object as ${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code>
                <dd>The expected object</dd>
            </dl>
          </div>
          <h3 id="<%= id('assert-equals') %>" data-title="+equals(actual, expected[, msg])+"><code>assert.equals(actual, expected[, message])</code></h3>
          <p>
            Compares <code>actual</code> to <code>expected</code> property for
            property. If the property count does not match, or if any
            of <code>actual</code>'s properties does not match the corresponding
            property in <code>expected</code> the assertion fails.
          </p>
          <p>
            If <code>actual</code> is <code>null</code>
            or <code>undefined</code>, an exact match is required. Date objects
            are compared by their <code>getTime</code> method. Regular
            expressions are compare by their string representations. Primitives
            are compared using <code>==</code>, i.e., with coercion.
          </p>
          <p>
            <code>equals</code> passes when comparing an <code>arguments</code>
            object to an array if the both contain the same elements.
          </p>
          <p>
            The optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var assert = assert;
assert.equals({ name: "Professor Chaos" }, { name: "Professor Chaos" }, "Passes");
assert.equals({ name: "Professor Chaos" }, { name: "Dr Evil" }, "Fails");
assert.equals({ name: "Professor Chaos" }, { name: "Professor Chaos" }); // Passes
assert.equals({ name: "Professor Chaos" }, { name: "Dr Evil" });         // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.equals.msgFail = "${0}Expected ${1} to be equal to ${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 data-title="+typeOf(object, expected[, msg])+"
              id="<%= id('assert-typeOf') %>"><code>assert.typeOf(object, expected[, message])</code></h3>
          <p>
            Fails if <code>typeof object</code> is not <code>expected</code>.  The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>assert.typeOf({}, "object", "This will pass");
assert.typeOf(null, "function", "This will fail");
assert.typeOf({}, "object");     // Passes
assert.typeOf(null, "function"); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.typeOf.msgFail = "${0}Expected typeof ${1} (${3}) to be ${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd>The expected type, a string</dd>
              <dt><code>${3}</code></dt>
              <dd><code>typeof object</code></dd>
            </dl>
          </div>
          <h3 data-title="+isObject(object[, msg])+" id="<%= id('assert-isObject') %>"><code>assert.isObject(object[, message])</code></h3>
          <p>
            Fails if <code>object</code> is not an object or if it
            is <code>null</code>.  The optional message is prepended to the
            failure message if provided.
          </p>
          <pre><code>assert.isObject({}, "This will pass");
assert.isObject(42, "This will fail");
assert.isObject([1, 2, 3]);      // Passes
assert.isObject(function () {}); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.isObject.msgFail = "${0}Expected typeof ${1} (${2}) to be object";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd><code>typeof object</code></dd>
            </dl>
          </div>
          <h3 data-title="+isNumber(object[, msg])+" id="<%= id('assert-isNumber') %>"><code>assert.isNumber(object[, message])</code></h3>
          <p>
            Fails if <code>object</code> is not a number <strong>or if it's
              NaN</strong>. NaN is rarely an expected value, even when expecting
            numbers. Use <code>isNaN</code> to check explicitly for NaN, or in
            those cases where you actually expect <strong>any</strong> number
            (including NaN), use
            <code>assert.typeOf</code>. The optional message is prepended to the
            failure message if provided.
          </p>
          <pre><code>assert.isNumber(42, "This will pass");
assert.isNumber({}, "This will fail");
assert.isNumber(1423); // Passes
assert.isNumber(NaN);  // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.isNumber.msgFail = "${0}Expected ${1} (${2}) to be a non-NaN number";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd><code>typeof object</code></dd>
            </dl>
          </div>
          <h3 data-title="+defined(object[, msg])+"
              id="<%= id('assert-defined') %>"><code>assert.defined(object[, message])</code></h3>
          <p>
            Fails if <code>object</code> is <code>undefined</code>. The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var a;
assert.defined({}, "This will pass");
assert.defined(undefined, "This will fail");
assert.defined({});  // Passes
assert.defined(a); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.defined.msgFail = "${0}Expected to be defined";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
            </dl>
          </div>
          <h3 data-title="+isNull(object[, msg])+" id="<%= id('assert-isNull') %>"><code>assert.isNull(object[, message])</code></h3>
          <p>
            Fails if <code>object</code> is not <code>null</code>.  The optional
            message is prepended to the failure message if provided.
          </p>
          <pre><code>assert.isNull(null, "This will pass");
assert.isNull({}, "This will fail");
assert.isNull(null); // Passes
assert.isNull({});   // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.isNull.msgFail = "${0}Expected ${1} to be null";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
            </dl>
          </div>
          <h3 data-title="+match(actual, matcher[, msg])+"
              id="<%= id('assert-match') %>"><code>assert.match(actual, matcher[, message])</code></h3>
          <p>
            Fails if <code>matcher</code> is not a partial match
            about <code>actual</code>. Accepts a wide range of input combinations.
          </p>
          <h4>String matcher</h4>
          <p>
            In its simplest form, <code>assert.match</code> performs a case
            insensitive substring match. When the matcher is a string,
            the <code>actual</code> object is converted to a string, and the
            assertion passes if <code>actual</code> is a case-insensitive
            substring of <code>expected</code> as a string.
          </p>
          <h4>Boolean matcher</h4>
          <p>
            Performs a strict (i.e. <code>===</code>) match with the
            object.
          </p>
          <pre><code>assert.match("Give me something", "Give", "This will pass");
assert.match("Give me something", "sumptn", "This will fail");
assert.match("Yeah!", { toString: function () { return "yeah"; } }); // Passes</code></pre>
          <h4>Regular expression matcher</h4>
          <p>
            When the matcher is a regular expression, the assertion will pass if
            <code>expected.test(actual)</code> is true. <code>assert.match</code>
            is written in a generic way, so any object with a <code>test</code>
            method will be used as a matcher this way.
          </p>
          <pre><code>assert.match("Give me something", /^[a-z\s]$/i, "This will pass");
assert.match("Give me something", /[0-9]/, "This will fail");
assert.match({ toString: function () { return "yeah!"; } }, /yeah/); // Passes
assert.match(234, /[a-z]/); // Fails</code></pre>
          <h4>Number matcher</h4>
          <p>
            When the matcher is a number, the assertion will pass if <code>matcher
              == actual</code>.
          </p>
          <pre><code>assert.match("123", 123, "This will pass");
assert.match("Give me something", 425, "This will fail");
assert.match({ toString: function () { return "42"; } }, 42); // Passes
assert.match(234, 1234); // Fails</code></pre>
          <h4>Function matcher</h4>
          <p>
            When the matcher is a function, it is called with <code>actual</code>
            as its only argument. The assertion will pass if the function
            returns <code>true</code>. A strict match is performed against the
            return value, so a boolean <code>true</code> is required, truthy is
            not enough.
          </p>
          <pre><code>assert.match("123", function (exp) {
    return exp == "123";
}, "This will pass");

assert.match("Give me something", function () {
    return "ok";
}, "This will fail");

assert.match({
    toString: function () {
        return "42";
    }
}, function () { return true; }); // Passes

assert.match(234, function () {}); // Fails</code></pre>
          <h4>Object matcher</h4>
          <p>
            As mentioned above, if an object matcher defines a <code>test</code>
            method the assertion will pass if <code>matcher.test(actual)</code>
            returns truthy. If the object does not have a <code>test</code>
            method, a recursive match is performed. If all properties
            of <code>matcher</code> matches corresponding properties
            in <code>actual</code>, the assertion passes.
          </p>
          <pre><code>assert.match("123", {
    test: function (arg) {
        return arg == 123;
    }
}, "This will pass");

assert.match({}, { prop: 42 }, "This will fail");

assert.match({
    name: "Chris",
    profession: "Programmer"
}, {
    name: "Chris"
}); // Passes

assert.match(234, {
    name: "Chris"
}); // Fails</code></pre>
          <h4>DOM elements</h4>
          <p>
            <code>assert.match</code> can be very helpful when asserting on DOM
            elements, because it allows you to compare several properties with
            one assertion:
          </p>
          <pre><code>var el = document.getElementById("myEl");

assert.match(el, {
    tagName: "h2",
    className: "item",
    innerHTML: "Howdy"
});</code></pre>
          <div class="msg">
            <h4>Messages</h4>
            <p><code>assert.match.msgException = "${0}${1}";</code></p>
            <p>
              Used when the matcher function throws an exception. This happens if
              the matcher is not any of the accepted types, for instance, a boolean.
            </p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>
                Message from exception thrown by matcher function.
              </dd>
            </dl>
            <p><code>assert.match.msgFail = "${0}Expected ${1} to match ${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 data-title="+exception(callback[, type[, msg]])+"
              id="<%= id('assert-exception') %>"><code>assert.exception(callback[, type[, message]])</code></h3>
          <p>
            Fails if <code>callback</code> does not throw an exception. If the
            optional <code>type</code> is provided, the assertion fails if the
            callback either does not throw an exception, <strong>or</strong> if
            the exception is not of the given type (determined by its
            <code>name</code> property).  The optional message is prepended to the
            failure message if provided.
          </p>
          <pre><code>assert.exception(function () {
    throw new Error("Ooops!");
}, null, "This will pass");

assert.exception(function () {}, null, "This will fail");

assert.exception(function () {
    throw new Error("Ooops!");
}); // Passes

assert.exception(function () {}); // Fails

assert.exception(function () {
    throw new TypeError("Ooops!");
}, "TypeError", "This will pass");

assert.exception(function () {
    throw new Error("Aww");
}, "TypeError", "This will fail, wrong exception type");

assert.exception(function () {
    throw new Error("Ooops!");
}, "Error"); // Passes

assert.exception(function () {}, "TypeError"); // Fails</code></pre>
          <div class="msg">
            <h4>Messages</h4>
            <p>
              <code>assert.exception.msgTypeNoException = "${0}Expected ${1} but no exception was thrown";</code><br>
              <code>assert.exception.msgFail = "${0}Expected exception";</code><br>
              <code>assert.exception.msgTypeFail = "${0}Expected ${1} but threw ${2}, (${3})";</code>
            </p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected exception type (if provided)</dd>
              <dt><code>${2}</code></dt>
              <dd>The type of exception thrown (if any)</dd>
              <dt><code>${3}</code></dt>
              <dd>The exception message</dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <h2 id="<%= id('dom-assertions') %>">Browser/DOM-specific assertions</h2>
          <h3 data-title="+tagName(element, tagName[, msg])+"
              id="<%= id('assert-tagName') %>"><code>assert.tagName(element, tagName[, message])</code></h3>
          <p>
            Fails if the <code>element</code> either does not specify
            a <code>tagName</code> property, or if its value is not a
            case-insensitive match with the expected <code>tagName</code>. The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>assert.tagName(document.createElement("p"), "p", "This will pass");
assert.tagName(document.createElement("p"), "li", "This will fail");
assert.tagName(document.createElement("h2"), "H2"); // Passes
assert.tagName(document.createElement("p"), "li");  // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.tagName.msgNoTagName = "${0}Expected ${2} to have tagName property";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected <code>tagName</code></dd>
              <dt><code>${2}</code></dt>
              <dd>
                If the object does not have a <code>tagName</code> property, this is
                the object. Otherwise, it is the value
                of <code>object.tagName</code>.
              </dd>
            </dl>
          </div>
          <h3 data-title="+className(element, tagName[, msg])+"
              id="<%= id('assert-className') %>"><code>assert.className(element, className[, message])</code></h3>
          <p>
            Fails if the <code>element</code> either does not specify
            a <code>className</code> property, or if its value is not a
            space-separated list of all class names in <code>classNames</code>.
          </p>
          <p>
            <code>classNames</code> can be either a space-delimited string or an
            array of class names. Every class specified by <code>classNames</code>
            must be found in the object's
            <code>className</code> property for the assertion to pass, but order
            does not matter.
          </p>
          <p>
            The optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var el = document.createElement("p");
el.className = "feed item blog-post";

assert.className(el, "item", "This will pass");
assert.className(el, "news", "This will fail");
assert.className(el, "blog-post feed"); // Passes
assert.className(el, "feed items");     // Fails, "items" is not a match
assert.className(el, ["item", "feed"]); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.className.msgNoClassName = "${0}Expected object to have className property";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected <code>classNames</code></dd>
              <dt><code>${2}</code></dt>
              <dd>The value of the object's <code>className</code> property, if any.</dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <h2 id="<%= id('refutations') %>">Refutations</h2>
          <p>
            Examples assume that you have
            aliased <code>buster.assertions.refute</code> as such:
          </p>
        <pre><code>var refute = buster.assertions.refute;</code></pre>
          <h3 id="<%= id('refute-same') %>" data-title="+same(expected, actual[, msg])+"><code>refute.same(expected, actual[, message])</code></h3>
          <p>
            Fails if <code>actual</code> <strong>is</strong> the same object
            (<code>===</code>) as <code>expected</code>. To compare similar
            objects, such as <code>{ name: "Chris", id: 42 }</code> and <code>{
              id: 42, name: "Chris" }</code> (not the same instance),
            see <%=l "refute.equals" %>. The optional message
            is prepended to the failure message if provided.
          </p>
          <pre><code>var obj = { id: 42, name: "Chris" };
refute.same(obj, { id: 42, name: "Chris" }, "This will pass");
refute.same(obj, obj, "This will fail");
refute.same(obj, { id: 42, name: "Chris" }); // Passes
refute.same(obj, obj);                       // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.same.msgFail = "${0}Expected ${1} not to be the same object as ${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 id="<%= id('refute-equals') %>" data-title="+equals(actual, expected[, msg])+"><code>refute.equals(actual, expected[, message])</code></h3>
          <p>
            Passes in any case where <%=l "assert.equals" %> fails.
            The optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var assert = assert;
refute.equals({ name: "Professor Chaos" }, { name: "Dr Evil" }, "Passes");
refute.equals({ name: "Professor Chaos" }, { name: "Professor Chaos" }, "Fails");
refute.equals({ name: "Professor Chaos" }, { name: "Dr Evil" });        // Passes
refute.equals({ name: "Professor Chaos" }, { name: "Professor Chaos" });// Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.equals.msgFail = "${0}Expected ${1} not to be equal to ${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 data-title="+typeOf(object, expected[, msg])+"
              id="<%= id('refute-typeOf') %>"><code>refute.typeOf(object, expected[, message])</code></h3>
          <p>
            Fails if <code>typeof object</code> is <code>expected</code>.  The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>refute.typeOf(null, "function", "This will pass");
refute.typeOf({}, "object", "This will fail");
refute.typeOf(null, "function"); // Passes
refute.typeOf({}, "object");     // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.typeOf.msgFail = "${0}Expected typeof ${1} not to be ${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd>The expected type, a string</dd>
            </dl>
          </div>
          <h3 data-title="+defined(object[, msg])+"
              id="<%= id('refute-defined') %>"><code>refute.defined(object[, message])</code></h3>
          <p>
            Fails if <code>object</code> is not <code>undefined</code>. The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var a;

refute.defined(undefined, "This will pass");
refute.defined({}, "This will fail");
refute.defined(a);  // Passes
refute.defined({}); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.defined.msgFail = "${0}Expected typeof ${1} (${2}) to be undefined";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${2}</code></dt>
              <dd><code>typeof object</code></dd>
            </dl>
          </div>
          <h3 data-title="+isNull(object[, msg])+"
              id="<%= id('refute-isNull') %>"><code>refute.isNull(object[, message])</code></h3>
          <p>
            Fails if <code>object</code> is <code>null</code>.  The optional
            message is prepended to the failure message if provided.
          </p>
          <pre><code>refute.isNull({}, "This will pass");
refute.isNull(null, "This will fail");
refute.isNull({});   // Passes
refute.isNull(null); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.isNull.msgFail = "${0}Expected not to be null";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
            </dl>
          </div>
          <h3 data-title="+match(actual, pattern[, msg])+"
              id="<%= id('refute-match') %>"><code>refute.match(actual, pattern[, message])</code></h3>
          <p>
            Fails in cases where <%= anchor("assert.match", "assert-match") %> passes.
          </p>
          <div class="msg">
            <h4>Messages</h4>
            <p><code>refute.match.msgException = "${0}${1}";</code></p>
            <p>
              Used when the matcher function throws an exception. This happens if
              the matcher is not any of the accepted types, for instance, a boolean.
            </p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>
                Message from exception thrown by matcher function.
              </dd>
            </dl>
            <p><code>refute.match.msgFail = "${0}Expected ${1} not to match ${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The actual objetc</dd>
              <dt><code>${2}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 data-title="+exception(callback[, msg])+"
              id="<%= id('refute-exception') %>"><code>refute.exception(callback[, message])</code></h3>
          <p>
            Fails if <code>callback</code> throws an exception.  The optional
            message is prepended to the failure message if provided.
          </p>
          <pre><code>refute.exception(function () {
    // Exercise code...
}, "This will pass");

refute.exception(function () {
    throw new Error("Ooops!");
}, "This will fail");

refute.exception(function () {
    // Exercise code...
}); // Passes

refute.exception(function () {
    throw new TypeError("Ooops!");
}); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.exception.msgFail = "${0}Expected not to throw but threw ${1}, (${2})";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The type of exception thrown (if any)</dd>
              <dt><code>${2}</code></dt>
              <dd>The exception message</dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <h2 id="<%= id('dom-refutations') %>">DOM-specific refutations</h2>
          <h3 data-title="+tagName(element, tagName[, msg])+"
              id="<%= id('refute-tagName') %>"><code>refute.tagName(element, tagName[, message])</code></h3>
          <p>
            Fails if the <code>element</code> either does not specify
            a <code>tagName</code> property, or if its value <strong>is</strong> a
            case-insensitive match with the expected <code>tagName</code>.  The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>refute.tagName(document.createElement("p"), "LI", "This will pass");
refute.tagName(document.createElement("p"), "p", "This will fail");
refute.tagName(document.createElement("h2"), "H3"); // Passes
refute.tagName(document.createElement("p"), "p");   // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.tagName.msgNoTagName = "${0}Expected ${2} to have tagName property";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected <code>tagName</code></dd>
              <dt><code>${2}</code></dt>
              <dd>
                If the object does not have a <code>tagName</code> property, this is
                the object.
              </dd>
            </dl>
          </div>
          <h3 data-title="+className(element, className[, msg])+"
              id="<%= id('refute-className') %>"><code>refute.className(element, className[, message])</code></h3>
          <p>
            Fails if the <code>element</code> either does not specify
            a <code>className</code> property, or if its value <strong>is</strong>
            a space-separated list of all class names in <code>classNames</code>.
          </p>
          <p>
            <code>classNames</code> can be either a space-delimited string or an
            array of class names. If any class specified
            by <code>classNames</code> is not found in the object's
            <code>className</code> property the assertion passes. Order does not
            matter.
          </p>
          <p>
            The optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var el = document.createElement("p");
el.className = "feed item blog-post";

refute.className(el, "chicken", "This will pass");
refute.className(el, "news", "This will fail");
refute.className(el, "blog-post rss");  // Passes
refute.className(el, "feed item");      // Fails
refute.className(el, ["item", "feed"]); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.className.msgNoClassName = "${0}Expected object to have className property";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The custom message, if any</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected <code>classNames</code></dd>
              <dt><code>${2}</code></dt>
              <dd>
                The value of the object's <code>className</code> property, if
                any. Otherwise, the object itself.
              </dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <h2 id="<%= id('methods') %>">Methods</h2>
          <h3 id="<%= id('fail') %>"><code>fail(message)</code></h3>
          <p>
            When an assertion fails, it calls <code>buster.assertions.fail</code> with
            the failure message as the only argument. The built-in
            <code>fail</code> function both throws an <%=l "AssertionError" %> and
            emits it to the <%=e "failure" %> event. The error can be caught and
            handled by the test runner. If this behavior is not suitable for your
            testing framework of choice, you can override
            <code>buster.assertions.fail</code> to make it do the right thing.
          </p>
          <p>
            Example: To use <strong>buster-assertions</strong> with JsTestDriver, you
            can simply configure it as follows:
          </p>
          <pre><code>buster.assertions.fail = function (message) {
    fail(message);
};</code></pre>
          <p>
            Where the global <code>fail</code> function is the one provided by
            JsTestDriver.
          </p>
          <p>
            It is possible to make the default <code>assert.fail</code> method
            only emit an event and not throw an error. This may be suitable in
            asynchronous test runners, where you might not be able to catch
            exceptions. To silence exceptions, see the <%=l "throwOnFailure" %>
            property.
          </p>
          <h3 id="<%= id('format') %>"><code>format(object)</code></h3>
          <p>
            Values inserted into assertion messages using the <code>${n}</code>
            switches are formatted using <code>buster.assertions.format(obj)</code>.
            By default this method simply coerces the object to a string.
          </p>
          <p>
            A more expressive option is to use <%=m "format" %>, which is a
            generic function for formatting objects nicely as ascii. For nice
            ascii formatting of objects (including DOM elements) do:
          </p>
          <pre><code>buster.assertions.format = buster.format.ascii;</code></pre>
          <h3 id="<%= id('add') %>"><code>add(name, func[, options])</code></h3>
          <p>
            Adds a custom assertion. Using this 'macro' to add project specific
            assertions has a few advantages:
          </p>
          <ul>
            <li>Assertions will be counted.</li>
            <li>
              Failure messages will have interpolated arguments formatted by
              <%= anchor("<code>buster.assertions.format</code>", "format") %>.
            </li>
            <li>
              A single function generates both an assertion and a refutation.
            </li>
            <li>
              If using expectations, an expectation can easily be generated as
              well.
            </li>
            <li>
              When <%=l "failOnNoAssertions" %> is set to <code>true</code>, the
              assertion will behave correctly (important for asynchronous tests).
            </li>
            <li>The assertion will fail if too few arguments are passed.</li>
          </ul>
          <p>
            Here's an example of adding a "foo" validator, that only passes when
            its only argument is the string "foo":
          </p>
          <pre><code>var assert = buster.assertions.assert;
var refute = buster.assertions.refute;
var expect = buster.assertions.expect;

buster.assertions.add("isFoo", function (actual) {
    return actual == "foo";
}, {
    assertFail: "Expected ${1} to be foo!",
    refuteFail: "Expected not to be foo!",
    expect: "toBeFoo"
});

// Now you can do:
// Passes
assert.isFoo("foo");

// Fails: "[assert.isFoo] Expected { id: 42 } to be foo!"
assert.isFoo({ id: 42 });

// Fails: "[assert.isFoo] Ouch: Expected { id: 42 } to be foo!"
assert.isFoo({ id: 42 }, "Ouch");

// Fails: "[refute.isFoo] Expected not to be foo!"
refute.isFoo("foo");

// Passes
expect("foo").toBeFoo();</code></pre>
          <h4>Arguments</h4>
          <h5><code>name</code></h5>
          <p>The name of the new assertion/refutation.</p>
          <h5><code>func</code></h5>
          <p>
            The verification function. Should return <code>true</code> when
            the assertion passes. The generated refutation will pass when the
            function returns false.
          </p>
          <p>
            In some cases the refutation may not be the exact opposite of the
            assertion. If that is the case you should exclude the
            <code>func</code> argument all together, and provide
            <code>options.assert</code> and <code>options.refute</code> for
            custom functions instead.
          </p>
          <p>
            Note that the number of formal parameters the function accepts
            determines the number of required arguments to the function.
          </p>
          <p>
            All arguments are available for interpolation into the resulting
            error message. The first argument will be available as
            <code>"${1}"</code>, the second as <code>"${2}"</code> and so on. If
            you need other values inserted into the error message, see the
            <code>values</code> option.
          </p>
          <h5><code>options</code></h5>
          <dl class="properties">
            <dt><code>assertFail</code></dt>
            <dd>
              The error message to use when the assertion fails. If the
              assertion was called with a custom message (as the last argument),
              it will be prepended to this message. The message may refer to
              arguments through switches like <code>"${1}"</code> and so on (see
              above, under the <code>func</code> argument).
            </dd>
            <dt><code>refuteFail</code></dt>
            <dd>Like <code>assertFail</code>, but for refutations</dd>
            <dt><code>values</code></dt>
            <dd>
              <p>
                A function that maps values to be interpolated into the failure
                messages. This can be used when you need something more/else than
                the actual arguments in order. For instance, the built-in
                <%= anchor("<code>assert.typeOf</code>", "assert-typeOf") %>
                assertion needs the actual type. It's <code>assertFail</code> is
                <code>"Expected typeof ${1} (${3}) to be ${2}"</code>, and its
                <code>values</code> option is:
              </p>
              <pre><code>values: function (actual, expected) {
    return [actual, expected, typeof actual];
}</code></pre>
            </dd>
            <dt><code>expect</code></dt>
            <dd>
              The name of the assertion as an expectation,
              e.g. "toBeSomething". Optional.
            </dd>
            <dt><code>assert</code></dt>
            <dd>
              If no <code>func</code> is provided, this function is the
              verification for the assert.
            </dd>
            <dt><code>refute</code></dt>
            <dd>
              If no <code>func</code> is provided, this function is the
              verification for the refute.
            </dd>
          </dl>
          <h2 id="<%= id('utilities') %>">Supporting utilities</h2>
          <h3 id="<%= id('isNode') %>"><code>isNode(object)</code></h3>
          <p>
            Returns <code>true</code> if the object is a DOM node. The check is made by
            attempting to call <code>appendChild</code> on it, passing in an element.
          </p>
          <h3 id="<%= id('isElement') %>"><code>isElement(object)</code></h3>
          <p>
            Returns <code>true</code> if the object is a DOM element. The check is made
            by calling <%=anchor "buster.isNode", "isNode" %> and asserting that the
            element's <code>nodeType</code> is 1 (i.e. element).
          </p>
          <h3 id="<%= id('isArguments') %>"><code>isArguments(object)</code></h3>
          <p>
            Returns true if the argument is an <code>arguments</code> object. Buster
            checks this by making sure the object is array-like, but not actually an
            array.
          </p>
          <pre><code>function check() {
              buster.isArguments(arguments); // true
              }

              buster.isArguments([]); // false</code></pre>
          <h3 id="<%= id('keys') %>"><code>keys(object)</code></h3>
          <p>
            Cross-browser implementation of
            <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys">Object.keys</a>.
            From MDC: <q>returns an array whose elements are strings
            corresponding to the enumerable properties found directly upon
            object. The ordering of the properties is the same as that given by
            looping over the properties of the object manually</q>.
          </p>
        </div>
        <div class="section">
          <h2 id="<%= id('properties') %>">Properties</h2>
          <%= property("count", "0") %>
          <p>
            <code>buster.assertions.count</code> is incremented anytime an assertion
            is called. The assertion counter can be reset to any number at your
            convenience.
          </p>
          <%= property("throwOnFailure", "true") %>
          <p>
            When using the <%= anchor("default <code>fail</code>", "fail") %>
            implementation, this property can be set to <code>false</code> to make
            assertion failures <strong>not</strong> throw exceptions (i.e. only
            emit events). This may be suitable in asynchronous test runners, where
            you might not be able to catch exceptions.
          </p>
        </div>
        <div class="section">
          <h2 id="<%= id('supporting-objects') %>">Supporting objects</h2>
          <h3 id="<%= id('AssertionError') %>"><code>AssertionError</code></h3>
          <p>
            An exception (specifically, an <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error"><code>Error</code> object</a>) whose <code>name</code> property is <code>"AssertionError"</code>.
          </p>
        </div>
