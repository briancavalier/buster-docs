<h1><code>buster.captureServer</code></h1>
<dl>
  <dt>Version</dt>
  <dd>0.2 <span class="date">(2011-10-04)</span></dd>
  <dt>Module</dt>
  <dd><code>require("buster-capture-server");</code></dd>
</dl>

<p>Loads HTML documents (sessions) into browsers (captured clients) via a HTTP API and/or a JavaScript API. Internally in buster, we create one session per test run. There are a number of uses for buster-server other than running tests, though. One example is <a href="http://github.com/augustl/slidebuster">Slidebuster</a>, where a session is a presentation, and the generic messaging in buster-capture-server is used to synchronize state across the captured browsers.</p>

<div class="section">
  <h2>Creating a server</h2>

  <h3 id="<%= id "create" %>"><code>var server = bCaptureServer.create()</code></h3>
  <p>Creates a new server instance.</p>

  <h3 id="<%= id "attach" %>"><code>server.attach(<a href="http://nodejs.org/docs/latest/api/http.html">httpServer</a>)</code></h3>
  <p>Attaches the buster-capture-server to a Node.js HTTP server.</p>
  <p>Normally, node HTTP servers will emit the <code>"request"</code> event to all listeners on all requests. This is <strong>not</strong> the case with buster-server. buster-server injects itself into the HTTP server so that the <code>"request"</code> handlers only run for requests that buster-server doesn't handle. Other than that, buster-server leaves the HTTP server untouched.</p>
</div>

<div class="section">
  <h2>Capturing browsers</h2>

  <p>Capturing browsers essentialy means opening a special buster-server HTML page in a web browser. This page has a frameset that consists of one hidden and one visible frame. The hidden frame is internal to buster-server and is responsible for loading sessions into the other frame, the visible one. This allows buster-server to dynamically change the visible part of the page, via network commands that buster-server sends to the hidden frame.</p>

  <h3 id="<%= id "oncapture" %>"><code>server.oncapture = function(req, res, <%= anchor "client", "captured-client" %>){}</code></h3>
  <p>This property is required.</p>

  <p>Capturing a browser is always done via a GET request to the <%= anchor "capturePath", "capture-path" %>. That request will set up everything buster-server needs to perform the capture (read: load the HTML page with the frameset).</p>

  <p>You are required to define the behaviour of the HTTP stack when everything has been set up and is ready to go.</p>

  <pre><code>server.oncapture = function (req, res, <%= anchor "client", "captured-client" %>) {
    res.writeHead(302, {"Location": client.<%= anchor "url", "captured-client-url" %>});
    res.end();
}</code></pre>
 
  <p>As with all HTTP requests, the request will hang and eventually time out if you don't manually <code>end()</code> the request.</p>

  <p>You are free to do whatever you want here. You don't have to redirect to the <%= anchor "captured client's URL", "captured-client-url" %>. You can for example redirect to a page that lets you configure additional options for the captured browser instead, and then redirect to the <code>client.url</code> when you're done.<</p>

  <h3 id="<%= id "capture-path" %>"><code>server.capturePath = "/capture"</code></h3>
  <p>The default value of this property is <code>"/capture"</code>.</p>

  <h3 id="<%= id "capture-header" %>"><code>server.header(height, resourceSet)</code></h3>
  <p>Adds a header to captured browsers. It is positioned above the main session frame, and is given the height specified. It will get the root resource loaded into it. It will stay in place when you change session, and even when there's no session in progress.</p>
  <pre><code>myServer.header(80, {
    resources: {"/": {content: "Hello, World!"}}
});</code></pre>
  <p>TODO: Write about the environment. We probably want messaging here, for example.</p>
</div>

<div class="section">
  <h2>Sessions</h2>

  <p>Sessions live in a FIFO queue. A session is loaded immediately if there are no sessions in progress at the time, or is added to the queue of sessions if there is one in progress. As soon as the in-progress session ends, the next session in the queue is automatically loaded.</p>
  <p>A session is very similar to a resource set. In fact, the APIs for creating a session takes a resource set payload 1:1.</p>    
  <p>When the session starts, buster-server sets the <code>"src"</code> property of the visible <code>&lt;frame&gt;</code> in each of the servers captured browsers to the URL to the root resource of the sessions resource set.</p>

  <h3 id="<%= id "create-session" %>"><code>var sess = server.createSession(sessionData)</code></h3>
  <p>Creates a new session. <code>sessionData</code> is identical to that of a resource set. TODO: link to resource set docs here.</p>

  <h3 id="<%= id "create-session-http" %>">POST /sessions</h3>

  <p>Creates a new session.</p>

  <h4>Request body</h4>
  <p>The payload for creating a session is identical to that of a resource set. TODO: Link to resource-set docs here.</p>

  <h4>Response body</h4>
  <pre><code>{
    "id": <%= anchor "session-id" %>,
    "rootPath": <%= anchor "session-root-path" %>,
    "bayeuxClientUrl": <%= anchor "session-bayeux-url" %>,
}</code></pre>

  <h4>Response status code</h4>
  <dl>
    <dt>201</dt>
    <dd>Session successfully created and will be loaded immediately.</dd>
    <dt>202</dt>
    <dd>Session successfully created and was queued.</dd>
  </dl>

  <h3 id="<%= id "stop-session" %>"><code>server.destroySession(<%= anchor "sess.id", "session-id" %>)</code></h3>
  <p>Stops the session with the given ID.</p>

  <h3 id="<%= id "stop-session-http" %>">DELETE <%= anchor "/session-root-path", "session-root-path" %></h3>
  <p>Stops the session with the given root path.</p>

  <h3 id="<%= id "session-id" %>"><code>sess.id</code></h3>
  <p>The ID of the session. TODO: Write about how this ID is useful for faye messaging.</p>

  <h3 id="<%= id "session-root-path" %>"><code>sess.rootPath</code></h3>
  <p>Used to kill the session.</p>

  <h3 id="<%= id "session-bayeux-url" %>"><code>sess.bayeuxClientUrl</code></h3>
  <p>The URL to use for creating Faye/bayeux clients. This property is also available on the server itself if you have programmatic access to it. The URL is the same for all sessions.</p>
</div>

<div class="section">
  <h2>Session browser runtime</h2>
  <p>These global variables are automatically available to all sessions. They are loaded before the session scripts so they can safely be referenced at all times in your session scripts.</p>

  <h3><code>buster</code></h3>
  <p>The buster-core module in its entirety.</p>

  <h3><code>buster.bayeuxClient</code></h3>
  <p>The Faye/bayeux client to use for messaging to other clients of the buster-server.</p>
  <p>buster-server imposes no restrictions on usage or event names. NOTE: this is not true, there are some events that are internal to buster-server sessions for starting and stopping sessions etc.</p>
  <p>Read documentation for the Faye clients <a href="http://faye.jcoglan.com/browser.html">here</a>.</p>
</div>

<div class="section">
  <h2 id="<%= id "captured-client" %>">Captured client</h2>
  <p>A captured client is the object that represents a captured browser. You usually only deal with this object in <code><%= anchor "server.oncapture", "oncapture" %></code>.</p>

  <h3 id="<%= id "captured-client-url" %>"><code>client.url</code></h3>
  <p>The URL to open in the browser in order to initiate the capture and load the frameset.</p>
</div>
