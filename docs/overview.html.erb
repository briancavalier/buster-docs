<h1>Buster.JS overview</h1>
<p>Buster.JS is a JavaScript test framework for node and browsers.</p>

<h2>Installation</h2>

<p>When you've installed <a href="http://nodejs.org/">Node 0.6.3 or later</a>, use <kbd>npm</kbd> to install Buster.JS</p>

<pre>npm install -g buster</pre>

<h2>The config file</h2>

<p>Buster.JS needs a config file, both for node.js tests and browser tests. Name the config file <kbd>buster.js</kbd> and put it in either <kbd>tests/</kbd> or <kbd>specs/</kbd> in your project.</p>

<pre><code>var config = module.exports;

config["My tests"] = {
    env: "browser",        // or "node"
    sources: [
        "../lib/mylib.js", // Paths are relative to config file
        "../lib/**/*.js"   // Basic glob patterns supported
    ],
    tests: [
        "*-test.js"
    ]
}</code></pre>

<p>Run tests for your config file with:</p>

<pre>buster test
// Assumes test/buster.js or spec/buster.js

buster test --config anywhere/buster.js
// Can also specify config file</pre>
<h2>Test cases</h2>

<p>Typically, you have one test case per file. Here's an example, in <kbd>test/my-thing-test.js</kbd>. Since the file name ends with <kbd>-test.js</kbd>, the config file above will load the test.</p>

<pre><code>buster.testCase("My thing", {
    "test something": function () {
        buster.assert.equals("foo", "bar");
    },

    "test other": function () {
        buster.assert(true);
    }
})</code></pre>

<p>Note that you are free to name your test cases whatever you want. They don't have to start with <code>"test ..."</code> or <code>"should ..."</code>.</p>

<h2>Browser testing</h2>

<p>Buster.JS can automate browsers, JsTestDriver style. First, start the server.</p>

<p><%= img "overview/buster-server-start.png", :width => "529", :height => "348" %></p>

<p>Open the browsers you want to run tests in and click the capture button.</p>

<p><%= img "overview/buster-server-capture-firefox.png", :width => "827", :height => "339" %></p>

<p>Buster.JS automatically runs the tests in all the captured browsers.</p>

<p><%= img "overview/buster-test-run-browsers.png", :width => "529", :height => "348" %></p>

<h2>Static HTML based browser testing</h2>

<p>Buster also has a static browser runner that runs tests by opening a web page in a browser. This is similar to QUnit, Mocha, etc.</p>

<p><%= img "overview/buster-static-start.png", :width => "529", :height => "348" %></p>

<p><%= img "overview/buster-static-success.png", :width => "514", :height => "470" %></p>

<h2>Node testing</h2>

<p>Works just like browser tests, but you need to require Buster.JS in your tests.</p>

<pre><code>var buster = require("buster");
var myLib = require("../lib/my-lib");

buster.testCase("A test case", {
    "test it": function () {
        buster.assert(myLib.doIt());
    }
})</code></pre>

<p>Specify <code>env: "node"</code> in the config file and you're good to go.</p>

<h2>Assertions</h2>

<p>Buster.JS comes <a href="https://busterjs.org/docs/buster-assertions/">packed with assertions</a>, and a simple DSl to add your own assertions.</p>

<pre><code>buster.assert(true);
buster.assert.same(two, objects);
buster.assert.equals(two, objects);
buster.assert.defined(something);
buster.assert.exception(function () { ... });
buster.assert.isNull();
// .. and many more</code></pre>

<p>Note the lack of <code>notEquals</code>, <code>notDefined</code> etc. Instead, Buster.JS provides a more symmetric API.</p>

<pre><code>// This assertion does not exist!
buster.assert.notEquals(foo, bar);

// Instead:
buster.refute.equals(two, objects);

// And so on
buster.refute(false);
buster.refute.same(two, objects);
buster.refute.defined(something);</code></pre>

<p>So instead of changing the function name, replace <code>assert</code> with <code>refute</code>.</p>

<p><code>buster.assert.match</code> is neat. All the assertions below will pass.</p>

<pre><code>// Partial property matching
var largeObject = {foo: "bar", baz: {test: "it"}};
buster.assert.match(largeObject, {foo: "bar"});

// Fancy string matching
buster.assert.match("Yeah!", { toString: function () { return "yeah"; } });

// Regexp matching
buster.assert.match("Give me something", /^[a-z\s]$/i);

// Lazy types
buster.assert.match("123", 123);

// DOM elements
var el = document.getElementById("myEl");

buster.assert.match(el, {
    tagName: "h2",
    className: "item",
    innerHTML: "Howdy"
});</code></pre>

<h2>BDD syntax</h2>

<p>Buster.JS is pluggable so you can write your own front-ends. Buster.JS also come with one extra front-end built in, the BDD spec style syntax.</p>

<pre><code>buster.spec.expose(); // Make functions global

var spec = describe("Bowling kata", function () {
    before(function () {
        this.game = new BowlingGame();

        this.rollMany = function (rolls, pins) {
            for (var i = 0; i < rolls; ++i) {
                this.game.roll(pins);
            }
        };
    });

    should("yield 0 in score for gutter game", function () {
        this.rollMany(20, 0);
        buster.assert.equals(0, this.game.score());
    });
});</code></pre>

<h2>Reporters</h2>

<p>There are a number of reporters built-in to Buster.JS, and you can also easily build your own reporters.</p>

<p>The default reporter, <kbd>dots</kbd>, which is what Buster.JS will use without <kbd>--reporters</kbd>:</p>

<p><%= img "overview/buster-test-reporter-dots.png", :width => "529", :height => "348" %></p>

<p>Other reporters:</p>

<p><%= img "overview/buster-test-reporter-specification.png", :width => "529", :height => "348" %></p>

<p><%= img "overview/buster-test-reporter-xml.png", :width => "529", :height => "348" %></p>

<p><%= img "overview/buster-test-reporter-quiet.png", :width => "529", :height => "348" %></p>

<p><%= img "overview/buster-test-reporter-tap.png", :width => "529", :height => "348" %></p>


<h2>Deferred/pending tests</h2>

<p>Commenting out an entire test case is bad. It will leave the test case out of the loop entirely, and you might forget to comment it back in again before pushing your code.</p>

<p>To remedy this, Buster.JS supports deferring a test so it doesn't actually run, but you get notified that there's a deferred tests every time you run your test suite.</p>

<p><%= img "overview/buster-test-deferred.png", :width => "529", :height => "348" %></p>

<p>To defer a test, add <kbd>//</kbd> to the start of the test name.</p>

<pre><code>buster.testCase("My tests", {
    "// test should bla bla bla test case": function () {
        // This function will not be called
    },

    "test this one is not deferred and will run": function () {
        buster.assert(true);
    }
})</code></pre>

<h2>Mocking and stubbing</h2>

<p><a href="http://sinonjs.org">Sinon.JS</a> is bundled with Buster.JS test cases. Every test in a test case has a sandbox associated with it, so its easy to mock and stub with no side effects beyond the scope of the test. <code>buster.assert</code> also comes with a lot of Sinon.JS aware assertions.</p>

<pre><code>buster.testCase("My tests", {
    "should demonstrate stubbing": function () {
        this.stub(myLib.thingie, "aMethod");
        doSomething();
        buster.assert.calledOnce(myLib.thingie.aMethod);
    }
})</code></pre>

<p>TODO: documentation is missing for the sinon-buster module. For now, refer to <a href="http://sinonjs.org/docs/">the Sinon.JS documentation</a> and do some guesswork...</p>

<h2>Asynchronous tests</h2>

<p>Asynchronous tests are tests that aren't finished running when the test method has finished executing. To tag a test as async, have the test function take one argument, <code>done</code>.</p>

<pre><code>buster.testCase("My thing", {
    "test not asynchronous": function () {
        buster.assert(true);
    },

    "test asynchronous": function (done) {
        myLibrary.doAjaxRequest("/foo", function (response) {
            buster.assert.equals(response.statusCode, 200);
            done();
        });
    }
})</code></pre>

<p>The <code>done</code> argument is a function. Call it to tell Bueter.JS that the asynchronous test has finished running. If you <em>don't</em> call <code>done</code>, the test will eventually time out and fail.</p>

<p><code>setUp</code> and <code>tearDown</code> can also be asynchronous. The procedure is identical to that of tests.</p>

<pre><code>buster.testCase("My thing", {
    setUp: function (done) {
        this.httpServer = http.createServer(function (req, res) {
            res.writeHead(418);
            res.end();
        });
        this.httpServer.listen(17171, function () { done(); });
        this.myThing = new MyThing();
        this.myThing.attach(this.httpServer);
    },

    tearDown: function (done) {
        this.httpServer.on("close", function () { done(); });
        this.httpServer.close();
    },

    // ... tests
})</code></pre>

<h2>Test case contexts</h2>

<p>A test case can have nested contexts, as deep as you want. Pass an object instead of a function to create a context.</p>

<pre><code>buster.testCase("My thing", {
    setUp: function () {
        this.myThing = new MyThing();
    },

    "test simple test": function () {
        buster.assert(true);
    },

    "on steroids": {
        setUp: function () {
            this.myThing.onSteroids = true;
        },

        // ... tests

        "with cowbell": {
            setUp: function () {
                this.myThing.cobwell = true;
            },

            // ... tests
        }
    }
})</code></pre>

<p><code>setUp</code> is called top-down, so when a test in the context <code>"with cowbell"</code> is called, the root <code>setUp</code> is called, then the one in <code>"on steroid"</code>, then lastly the one in <code>"with cowbell"</code>. The <code>this</code> is the same in all contexts.</p>

<h2>Proxying to http servers</h2>

<p>In your browser tests you might want to perform HTTP request to a server, such as your application server. This can be difficult since your tests run via the Buster.JS server, and you can't access your application server due to cross domain origin policies in browsers.</p>

<p>To remedy this, Buster.JS lets you set up a proxy server in your config file.</p>

<pre><code>var config = module.exports;

config["My tests"] = {
    sources: ["../lib/**/*.js"],
    tests: ["*-test.js"],
    resources: {
        "/app": "http://192.168.1.200:3030"
    }
}</code></pre>

<p>A request to <kbd>/app/foo</kbd> will be proxied to <kbd>http://192.168.1.200:3030/foo</kbd>.</p>

<p>If you're talking to an app server with state, you probably want to reset it before every test to avoid leaks from test case to test case. You're responsible for doing that yourself. Here's an example using an asynchronous setUp that won't run the test until the request to reset the app server has ended.</p>

<pre><code>buster.testCase("My tests", {
    setUp: function (done) {
        myHttpLib("/app/reset", {
            success: function () { done(); }
        });
    },

    // ... tests here ...
})</code></pre>

<h2>Running a subset of tests</h2>

<p>To run a single test, pass it's full name as an operand to <kbd>buster test</kbd>.</p>

<pre>buster test "My tests should run this particular test"</pre>

<p>The operand is treated as a JavaScript regular expression so you can do partial matching and regex stuff in it as well.</p>

<pre>buster test "* delete user"</pre>

<p>To run a single file, do this:</p>

<pre>buster test --file test/mytest.js</pre>

<p>This assumes the presence of a config file, and just like plain <kbd>buster test</kbd> it tries to find a config file automatically, if you don't specify one with <kbd>--config</kbd>. Buster needs the config file to load your proxies, library code, dependencies, and so on.</p>


<h2>Testing AJAX</h2>

<p>Buster.JS comes with Sinon.JS. This makes mocking out the entire XHR stack in a browser trivial.</p>

<pre><code>buster.testCase("My tests", {
    setUp: function () {
        this.server = this.fakeServer.create();
    },

    "should POST to /todo-items": function () {
        myThing.createTodoItem("Some item");

        buster.assert.equals(this.server.requests.length, 1);
        buster.assert.match(this.server.requests[0], {
            method: "POST",
            url: "/todo-items"
        });
    },

    "should yield list item to callback on success": function () {
        this.server.respondsWith(
            "POST",
            "/todo-items",
            [200, {"content-type": "application/json"},
            '{"text":"Fetch eggs","done":false,"id":1}']);

        var callback = this.spy();
        // Assuming implementation calls the callback with a JSON.parsed
        // response body when the request ends
        myThing.createTodoItem("Fetch eggs", callback);

        // Cause the request to respond, based on respondsWith above.
        this.server.respond();

        // Sinon.JS replaces the entire XHR stack and synchronously handles
        // the request.
        buster.assert.calledOnce(callback);
        buster.assert.equals(callback.getCall(0).args[0], {
            test: "Fetch eggs", done: false, id: 1
        });
    }
})</code></pre>

<p>Sinon.JS will mock out XMLHTTPRequest at the lowest possible level, so your HTTP libraries doesn't need any modification to be testable in this way. Even if you use jQuery or another 3rd party library for your HTTP.</p>

<h2>Feature detection</h2>

<p>You can tell Buster.JS to not run certain test cases in certain situations. This is useful if you want to run the same test suite for a program that works in IE6, so you want to run most of your tests in IE6, but also has features that will crash when called in IE6.</p>

<pre><code>buster.testCase("My thing", {
    requiresSupportFor: {
        "touch events": typeof(document.body.ontouchstart) != "object",
        "XHR": typeof(XMLHttpRequest) != "undefined"
    },

    "should receive touch events": function () {
        // ..
    },

    // ...
});</code></pre>

<p>You can also apply the feature detection filter to nested contexts to only filter out a subset of the test case.</p>

<h2>Custom test beds</h2>

<p class="warning">
  Note: this feature has not yet landed in the beta. Currently it can sort of be achieved by adding <code>resources: [{path: "/", content: "html here"}]</code> to the config file.
</p>

<p>For browser tests, you can specify the HTML document the tests will run in. Buster.JS defaults to a plain HTML5 document. But you might want to run the tests in a HTML4 strict environment, and what not.</p>

<pre><code>var config = module.exports;

config["My tests"] = {
    sources: ["../lib/**/*.js"],
    tests: ["*-test.js"],
    testbed: "my-file.html"
}</code></pre>

<p>Script tags for your tests will be added automatically at the ending body tag, or at the end of the document if no ending body tag is present.</p>

<h2>Headless browser testing</h2>

<p class="warning">
  Note: this feature has not yet landed in the beta.
</p>

<p>You don't need a browser to do browser testing with Buster.JS. By running tests and not starting a server, Buster.JS will automatically run the tests headless in a PhantomJS browser.</p>

<p>This is particularly convenient for integration of Buster.JS with editors and IDEs. You can provide a simple "play button" to run the tests, and you don't need to do anything other than shelling out to <kbd>buster test</kbd> which will take care of running the tests in PhantomJS even if there's no Buster.JS server running.</p>

<h2>Editor integration</h2>
<h3>TextMate</h3>
<p>Magnar Sveen maintains <a href="https://github.com/magnars/buster.tmbundle">TextMate bundle</a>. It includes snippets, running tests with <kbd>command + R</kbd>, and more.</p>

<h3>Emacs</h3>
<p>Christian Johansen maintains <a href="https://gitorious.org/buster/buster-mode">buster-mode.el</a>.</p>

<p>Magnar Sveen has written a set of <a href="https://github.com/magnars/buster-snippets.el">yasnippet snippets for Buster.JS</a>.</p>
